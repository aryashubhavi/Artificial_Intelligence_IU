#!/usr/local/bin/python3
# solver2021.py : 2021 Sliding tile puzzle solver
#
# Code by:
#  primary
#   Aishwarya Budhkar (abudhkar)
#  secondary
#   Shubhavi Arya     (aryas)
#   Jacob Striebel    (jstrieb)
#
# Based on skeleton code by D. Crandall & B551 Staff, September 2021
#

import sys
import numpy as np
from queue import PriorityQueue
import copy

ROWS=5
COLS=5

# Stores the board state with board configuration, cost and heuristic
class BoardState:
    def __init__(self, board, cost, heuristic):
        self.board = board
        self.cost = cost
        self.heuristic = heuristic

    # Used to determine priority in priority queue
    def __lt__(self, different):
        return self.cost + self.heuristic < different.cost + different.heuristic

def printable_board(board):
    return [ ('%3d ')*COLS  % board[j:(j+COLS)] for j in range(0, ROWS*COLS, COLS) ]

# Gets successors of current board
def successors(state, moves, heuristic_dict):
    successorList = []

    # Successors generated by sliding columns up
    for col in range(0,5):
        currState = copy.deepcopy(state.board)
        moves_copy = copy.deepcopy(moves)

        # Slide column up
        slideColumnUpBoard = transpose_board(move_left(transpose_board(currState),col))
        moves_copy.append("U"+str(col+1))

        # Using manhattan distance heuristic
        if(str(slideColumnUpBoard) not in heuristic_dict):
            heuristic = calculateHeuristicManhattanDistanceRowColumn(slideColumnUpBoard)
            heuristic_dict[str(slideColumnUpBoard)]=heuristic
            # New state cost will be 1 more than the current board
            newState = BoardState(slideColumnUpBoard, state.cost + 1, heuristic)
            successorList.append((newState,moves_copy))
        else:
            heuristic = heuristic_dict[str(slideColumnUpBoard)]
            newState = BoardState(slideColumnUpBoard, state.cost + 1, heuristic)
            successorList.append((newState,moves_copy))

    # Successors generated by sliding columns down
    for col in range(0,5):
        currState = copy.deepcopy(state.board)
        moves_copy = copy.deepcopy(moves)

        # Slide column down
        slideColumnDownBoard = transpose_board(move_right(transpose_board(currState), col))
        moves_copy.append("D"+str(col+1))

        # Using manhattan distance heuristic
        if(str(slideColumnDownBoard) not in heuristic_dict):
            heuristic = calculateHeuristicManhattanDistanceRowColumn(slideColumnDownBoard)
            heuristic_dict[str(slideColumnUpBoard)]=heuristic
            # New state cost will be 1 more than the current board
            newState = BoardState(slideColumnDownBoard, state.cost + 1, heuristic)
            successorList.append((newState,moves_copy))
        else:
            heuristic = heuristic_dict[str(slideColumnDownBoard)]
            newState = BoardState(slideColumnDownBoard, state.cost + 1, heuristic)
            successorList.append((newState,moves_copy))

    # Successors generated by sliding rows left
    for row in range(0,5):
        currState = copy.deepcopy(state.board)
        moves_copy = copy.deepcopy(moves)

        # Slide row left
        slideRowLeftBoard = move_left(currState, row)
        moves_copy.append("L"+str(row+1))

        # Using manhattan distance heuristic
        if(str(slideRowLeftBoard ) not in heuristic_dict):
            heuristic = calculateHeuristicManhattanDistanceRowColumn(slideRowLeftBoard)
            heuristic_dict[str(slideRowLeftBoard)]=heuristic
            # New state cost will be 1 more than the current board
            newState = BoardState(slideRowLeftBoard, state.cost + 1, heuristic)
            successorList.append((newState,moves_copy))
        else:
            heuristic = heuristic_dict[str(slideRowLeftBoard)]
            newState = BoardState(slideRowLeftBoard, state.cost + 1, heuristic)
            successorList.append((newState,moves_copy))

    # Successors generated by sliding rows right
    for row in range(0,5):
        currState = copy.deepcopy(state.board)
        moves_copy = copy.deepcopy(moves)

        # Slide row right
        slideRowRightBoard = move_right(currState, row)
        moves_copy.append("R"+str(row+1))

        # Using manhattan distance heuristic
        if(str(slideRowRightBoard) not in heuristic_dict):
            heuristic = calculateHeuristicManhattanDistanceRowColumn(slideRowRightBoard)
            heuristic_dict[str(slideRowRightBoard)]=heuristic
            # New state cost will be 1 more than the current board
            newState = BoardState(slideRowRightBoard, state.cost + 1, heuristic)
            successorList.append((newState,moves_copy))
        else:
            heuristic = heuristic_dict[str(slideRowRightBoard)]
            newState = BoardState(slideRowRightBoard, state.cost + 1, heuristic)
            successorList.append((newState,moves_copy))

    # Successors generated by moving the outer ring clockwise
    currState = copy.deepcopy(state.board)
    moves_copy = copy.deepcopy(moves)

    moveOuterRingClockwiseBoard = move_outer_clockwise(currState)
    moves_copy.append("Oc")

    # Using manhattan distance heuristic
    if(str(moveOuterRingClockwiseBoard) not in heuristic_dict):
        heuristic = calculateHeuristicManhattanDistanceOuterRing(moveOuterRingClockwiseBoard)
        heuristic_dict[str(moveOuterRingClockwiseBoard)]=heuristic
        # New state cost will be 1 more than the current board
        newState = BoardState(moveOuterRingClockwiseBoard, state.cost + 1, heuristic)
        successorList.append((newState,moves_copy))
    else:
        heuristic = heuristic_dict[str(moveOuterRingClockwiseBoard)]
        newState = BoardState(moveOuterRingClockwiseBoard, state.cost + 1, heuristic)
        successorList.append((newState,moves_copy))

    # Successors generated by moving the outer ring anti clockwise
    currState = copy.deepcopy(currState)
    moves_copy = copy.deepcopy(moves)

    moveOuterRingAntiClockwiseBoard = move_outer_cclockwise(currState)
    moves_copy.append("Occ")

    # Using manhattan distance heuristic
    if(str(moveOuterRingAntiClockwiseBoard) not in heuristic_dict):
        heuristic = calculateHeuristicManhattanDistanceOuterRing(moveOuterRingAntiClockwiseBoard)
        heuristic_dict[str(moveOuterRingAntiClockwiseBoard)]=heuristic
        # New state cost will be 1 more than the current board
        newState = BoardState(moveOuterRingAntiClockwiseBoard, state.cost + 1, heuristic)
        successorList.append((newState,moves_copy))
    else:
        heuristic = heuristic_dict[str(moveOuterRingAntiClockwiseBoard)]
        newState = BoardState(moveOuterRingAntiClockwiseBoard, state.cost + 1, heuristic)
        successorList.append((newState,moves_copy))

    # Successors generated by moving the inner ring clockwise
    currState = copy.deepcopy(currState)
    moves_copy = copy.deepcopy(moves)

    moveInnerRingClockwiseBoard = move_inner_clockwise(currState)
    moves_copy.append("Ic")

    # Using manhattan distance heuristic
    if(str(moveInnerRingClockwiseBoard) not in heuristic_dict):
        heuristic = calculateHeuristicManhattanDistanceInnerRing(moveInnerRingClockwiseBoard)
        heuristic_dict[str(moveInnerRingClockwiseBoard)]=heuristic
        # New state cost will be 1 more than the current board
        newState = BoardState(moveInnerRingClockwiseBoard, state.cost + 1, heuristic)
        successorList.append((newState,moves_copy))
    else:
        heuristic = heuristic_dict[str(moveInnerRingClockwiseBoard)]
        newState = BoardState(moveInnerRingClockwiseBoard, state.cost + 1, heuristic)
        successorList.append((newState,moves_copy))

    # Successors generated by moving the inner ring anti clockwise
    currState = copy.deepcopy(state.board)
    moves_copy = copy.deepcopy(moves)

    moveInnerRingAntiClockwiseBoard = move_inner_cclockwise(currState)
    moves_copy.append("Icc")

    # Using manhattan distance heuristic
    if(str(moveInnerRingAntiClockwiseBoard) not in heuristic_dict):
        heuristic = calculateHeuristicManhattanDistanceInnerRing(moveInnerRingAntiClockwiseBoard)
        heuristic_dict[str(moveInnerRingAntiClockwiseBoard)]=heuristic
        # New state cost will be 1 more than the current board
        newState = BoardState(moveInnerRingAntiClockwiseBoard, state.cost + 1, heuristic)
        successorList.append((newState,moves_copy))
    else:
        heuristic = heuristic_dict[str(moveInnerRingAntiClockwiseBoard)]
        newState = BoardState(moveInnerRingAntiClockwiseBoard, state.cost + 1, heuristic)
        successorList.append((newState,moves_copy))

    return successorList

# Functions for matrix transformations
"""
Following functions are used from the test file provided
"""
def move_right(board, row):
      board1 = copy.deepcopy(board)
      """Move the given row to one position right"""
      board1[row] = board1[row][-1:] + board1[row][:-1]
      return board1

def move_left(board, row):
      board1 = copy.deepcopy(board)
      """Move the given row to one position left"""
      board1[row] = board1[row][1:] + board1[row][:1]
      return board1
"""
End of code from the test file provided
"""

def move_outer_clockwise(board):
    board1 = copy.deepcopy(board)
    board1[0][0] = board[1][0]
    board1[0][1] = board[0][0]
    board1[0][2] = board[0][1]
    board1[0][3] = board[0][2]
    board1[0][4] = board[0][3]
    board1[1][0] = board[2][0]
    board1[2][0] = board[3][0]
    board1[3][0] = board[4][0]
    board1[4][0] = board[4][1]
    board1[4][1] = board[4][2]
    board1[4][2] = board[4][3]
    board1[4][3] = board[4][4]
    board1[4][4] = board[3][4]
    board1[3][4] = board[2][4]
    board1[2][4] = board[1][4]
    board1[1][4] = board[0][4]
    return board1

def move_outer_cclockwise(board):
    board1 = copy.deepcopy(board)
    board1[0][1] = board[0][0]
    board1[0][2] = board[0][1]
    board1[0][3] = board[0][2]
    board1[0][4] = board[0][3]
    board1[1][4] = board[0][4]
    board1[0][0] = board[1][0]
    board1[1][0] = board[2][0]
    board1[2][0] = board[3][0]
    board1[3][0] = board[4][0]
    board1[4][0] = board[4][1]
    board1[4][1] = board[4][2]
    board1[4][2] = board[4][3]
    board1[4][3] = board[4][4]
    board1[4][4] = board[3][4]
    board1[3][4] = board[2][4]
    board1[2][4] = board[1][4]
    return board1

def move_inner_clockwise(board):
    board1 = copy.deepcopy(board)
    board1[1][1] = board[2][1]
    board1[1][2] = board[1][1]
    board1[1][3] = board[1][2]
    board1[2][1] = board[3][1]
    board1[2][2] = board[2][2]
    board1[2][3] = board[1][3]
    board1[3][1] = board[3][2]
    board1[3][2] = board[3][3]
    board1[3][3] = board[2][3]
    return board1

def move_inner_cclockwise(board):
    board1 = copy.deepcopy(board)
    board1[1][1] = board[1][2]
    board1[1][2] = board[1][3]
    board1[1][3] = board[2][3]
    board1[2][1] = board[1][1]
    board1[2][2] = board[2][2]
    board1[2][3] = board[3][3]
    board1[3][1] = board[2][1]
    board1[3][2] = board[3][1]
    board1[3][3] = board[3][2]
    return board1

"""
Following lines are used from the test file
"""
def transpose_board(board):
  board1 = copy.deepcopy(board)
  """Transpose the board --> change row to column"""
  return [list(col) for col in zip(*board1)]
"""
End of code from test file
"""
# check if we've reached the goal
def is_goal(state):
    if state == [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]:
        return True
    else:
        return False

# To check the position of number on current board
def check_position_of_number(board, number):
    for i in range(5):
        for j in range(5):
            if board[i][j] == number:
                return i, j

# manhattan distance heuristic
# Calculates the number of tiles which differ in position in current board compared to the goal board configuration
# Returns number/16 to account for the maximum number of tiles that can change places in one move is 16 for move outer ring to make it admissible
def calculateHeuristicMisplacedTilesOuterRingAdmissible(board):
    goal_board = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]
    count = 0
    for i in range(len(board)):
        for j in range(len(board[0])):
            if(board[i][j]!=goal_board[i][j]):
                count+=1
    return count/16

# manhattan distance heuristic
# Calculates the number of tiles which differ in position in current board compared to the goal board configuration
# Returns number/8 to account for the maximum number of tiles that can change places in one move is 8 for move inner ring to make it admissible
def calculateHeuristicMisplacedTilesInnerRingAdmissible(board):
    goal_board = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]
    count = 0
    for i in range(len(board)):
        for j in range(len(board[0])):
            if(board[i][j]!=goal_board[i][j]):
                count+=1
    return count/8

# manhattan distance heuristic
# Calculates the number of tiles which differ in position in current board compared to the goal board configuration
# Returns number/5 to account for the maximum number of tiles that can change places in one move is 5 for move rows/columns to make it admissible
def calculateHeuristicMisplacedTilesRowColumnAdmissible(board):
    goal_board = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]
    count = 0
    for i in range(len(board)):
        for j in range(len(board[0])):
            if(board[i][j]!=goal_board[i][j]):
                count+=1
    return count/5

# manhattan distance heuristic
# Calculates the number of tiles which differ in position in current board compared to the goal board configuration
def calculateHeuristicMisplacedTiles(board):
    goal_board = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]
    count = 0
    for i in range(len(board)):
        for j in range(len(board[0])):
            if(board[i][j]!=goal_board[i][j]):
                count+=1
    return count/16

def getCoordinatesInGoalBoard(number):
    goal_board = [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]
    for i in range(5):
        for j in range(5):
            if(goal_board[i][j] == number):
                return i,j

# Calculates manhattan distance between current board and goal board.
def calculateHeuristicManhattanDistance(board):
    manhattan_distance = 0
    for i in range(5):
        for j in range(5):
            number = board[i][j]
            row, col = getCoordinatesInGoalBoard(number)
            manhattan_distance += (abs(row-i) + abs(col-j))
    return manhattan_distance

# Calculates manhattan distance between current board and goal board.
# Returns distance/5 to account for the maximum number of tiles that can change places in one move is 5 to make it admissible
def calculateHeuristicManhattanDistanceRowColumn(board):
    manhattan_distance = 0
    for i in range(5):
        for j in range(5):
            number = board[i][j]
            row, col = getCoordinatesInGoalBoard(number)
            manhattan_distance += (abs(row-i) + abs(col-j))
    return manhattan_distance/5

# Calculates manhattan distance between current board and goal board.
# Returns number/16 to account for the maximum number of tiles that can change places in one move is 16 to make it admissible
def calculateHeuristicManhattanDistanceOuterRing(board):
    manhattan_distance = 0
    for i in range(5):
        for j in range(5):
            number = board[i][j]
            row, col = getCoordinatesInGoalBoard(number)
            manhattan_distance += (abs(row-i) + abs(col-j))
    return manhattan_distance/16

# Calculates manhattan distance between current board and goal board.
# Returns number/8 to account for the maximum number of tiles that can change places in one move is 8 to make it admissible
def calculateHeuristicManhattanDistanceInnerRing(board):
    manhattan_distance = 0
    for i in range(5):
        for j in range(5):
            number = board[i][j]
            row, col = getCoordinatesInGoalBoard(number)
            manhattan_distance += (abs(row-i) + abs(col-j))
    return manhattan_distance/8

"""
Solving using A* search algorithm
"""
def solve(initial_board):
    """
    1. This function should return the solution as instructed in assignment, consisting of a list of moves like ["R2","D2","U1"].
    2. Do not add any extra parameters to the solve() function, or it will break our grading and testing code.
       For testing we will call this function with single argument(initial_board) and it should return
       the solution.
    3. Please do not use any global variables, as it may cause the testing code to fail.
    4. You can assume that all test cases will be solvable.
    5. The current code just returns a dummy solution.
    """

    # Store board as list of lists, 2D matrix
    initial_board_matrix = []
    i=0
    while(i<(len(list(initial_board))-4)):
        cnt = 0
        row = []
        while(cnt<5):
            row.append(initial_board[i+cnt])
            cnt+=1
        initial_board_matrix.append(row)
        i = i+5

    # Store visited boards to avoid duplicate computations
    visitedState = {}

    # Stores the list of moves taken to reach the current state
    moves = []

    # Stores the heuristic for a board
    heuristic_dict = {}
    # Using manhattan distance heuristic
    heuristic = calculateHeuristicManhattanDistance(initial_board_matrix)

    initialState = BoardState(initial_board_matrix, 0, heuristic)
    heuristic_dict[str(initial_board_matrix)]=heuristic
    # initial board is goal board
    # Solution found in 0 moves, i.e. no move required
    # returning empty list of moves
    if heuristic == 0:
        return []

    # PriorityQueue to store the states
    q = PriorityQueue()

    q.put((initialState,moves))
    visitedState[str(initial_board)]=''
    goalFound = False

    while not q.empty() and goalFound == False:

        # Get the min cost state and cost
        board = q.get()

        # Get all successors for the state
        successorStateList = successors(board[0], board[1], heuristic_dict)

        # For every successor return moves required to reach goal if it is goal else add to priority queue if not already visited
        for (child,moves) in successorStateList:

            # If successor not visited
            if str(child.board) not in visitedState:
                visitedState[str(child.board)]=''

                # If goal found break
                if is_goal(child.board):
                    goalFound = True
                    break

                # Add child to priority queue
                q.put((child,moves))

    # Return moves required to reach the goal state
    return moves


# Please don't modify anything below this line
#
if __name__ == "__main__":
    if(len(sys.argv) != 2):
        raise(Exception("Error: expected a board filename"))

    start_state = []
    with open(sys.argv[1], 'r') as file:
        for line in file:
            start_state += [ int(i) for i in line.split() ]

    if len(start_state) != ROWS*COLS:
        raise(Exception("Error: couldn't parse start state file"))

    print("Start state: \n" +"\n".join(printable_board(tuple(start_state))))

    print("Solving...")
    route = solve(tuple(start_state))

    print("Solution found in " + str(len(route)) + " moves:" + "\n" + " ".join(route))
